#pragma once

#include <cstdint>

#include <vector>

#include "../GeneralKeyTypes.h"
#include "../ArrayPtrAndSize.h"

namespace Decent
{
	namespace Tools
	{
		namespace detail
		{
			void PlatformAesGcmEncrypt(const void* keyPtr, const size_t keySize, const void* srcPtr, const size_t srcSize,
				void* destPtr,
				const void* ivPtr, const size_t ivSize,
				const void* addPtr, const size_t addSize,
				void* tagPtr, const size_t tagSize);

			void PlatformAesGcmDecrypt(const void* keyPtr, const size_t keySize, const void* srcPtr, const size_t srcSize,
				void* destPtr,
				const void* ivPtr, const size_t ivSize,
				const void* addPtr, const size_t addSize,
				const void* tagPtr, const size_t tagSize);

			std::vector<uint8_t> QuickAesGcmPack(const void* keyPtr, const size_t keySize,
				const void* inKeyMeta, const size_t inKeyMetaSize,
				const void* inMeta, const size_t inMetaSize,
				const void* inData, const size_t inDataSize,
				General128Tag& outTag,
				const size_t sealedBlockSize);

			std::vector<uint8_t> GetKeyMetaFromPack(const void* inEncData, const size_t inEncDataSize);

			void QuickAesGcmUnpack(const void* keyPtr, const size_t keySize,
				const void* inEncData, const size_t inEncDataSize,
				std::vector<uint8_t>& outMeta, std::vector<uint8_t>& outData,
				const General128Tag* inTag,
				const size_t sealedBlockSize);
		}

		/**
		 * \brief	Quickly encrypt secret with AES-GCM and pack all necessary data together
		 *
		 * \exception	Decent::RuntimeException	throw when argument(s) is invalid, or error occurred
		 * 											in underlying function calls.
		 *
		 * \tparam	KeyType	   	Type of the key.
		 * \tparam	KeyMetaType	Type of the key metadata.
		 * \tparam	MetaType   	Type of the metadata.
		 * \tparam	DataType   	Type of the data.
		 * \param 		  	key			   	The key used for encryption.
		 * \param [out]	outTag		   	The output tag, which can be used to verify the version of
		 * 									the secret.
		 * \param 		  	keyMeta		   	The key metadata (only MACed), which can be used to recover
		 * 									the key when decryption.
		 * \param 		  	meta		   	The metadata (encrypted), the secret metadata.
		 * \param 		  	data		   	The secret data.
		 * \param 		  	sealedBlockSize	The step size of the sealed block.
		 *
		 * \return	A std::vector&lt;uint8_t&gt; containing the entire package.
		 */
		template<typename KeyType, typename KeyMetaType, typename MetaType, typename DataType>
		std::vector<uint8_t> QuickAesGcmPack(const KeyType& key, const KeyMetaType& keyMeta, const MetaType& meta, const DataType& data, General128Tag& outTag, const size_t sealedBlockSize)
		{
			using namespace ArrayPtrAndSize;
			return detail::QuickAesGcmPack(GetPtr(key), GetSize(key),
				GetPtr(keyMeta), GetSize(keyMeta),
				GetPtr(meta), GetSize(meta),
				GetPtr(data), GetSize(data),
				outTag,
				sealedBlockSize);
		}

		/**
		 * \brief	Simply gets key metadata from the package. There is no structure verification, nor
		 * 			tag verification. The structure and tag should be verified in QuickAesGcmUnpack
		 *
		 * \tparam	DataType	Type of the data.
		 * \param	encData	Encrypted data package.
		 *
		 * \return	The key meta from pack.
		 */
		template<typename DataType>
		std::vector<uint8_t> GetKeyMetaFromPack(const DataType& encData)
		{
			using namespace ArrayPtrAndSize;
			return detail::GetKeyMetaFromPack(GetPtr(encData), GetSize(encData));
		}

		/**
		 * \brief	Quickly unpack and decrypt the AES-GCM package
		 *
		 * \tparam	KeyType 	Type of the key.
		 * \tparam	DataType	Type of the data.
		 * \param 	   	key			   	The key used for decryption.
		 * \param 	   	encData		   	The encrypted package generated by QuickAesGcmPack.
		 * \param 	   	inTag		   	The input tag. (Optional) If it's not null, it will be used to
		 * 								compare with the tag stored in the package.
		 * \param [out]	outMeta		   	The output secret metadata.
		 * \param [out]	outData		   	The output secret data.
		 * \param 	   	sealedBlockSize	The step size of the sealed block (must be the same as the one
		 * 								used in QuickAesGcmPack).
		 */
		template<typename KeyType, typename DataType>
		void QuickAesGcmUnpack(const KeyType& key, const DataType& encData,
				std::vector<uint8_t>& outMeta, std::vector<uint8_t>& outData,
				const General128Tag* inTag, const size_t sealedBlockSize)
		{
			using namespace ArrayPtrAndSize;
			return detail::QuickAesGcmUnpack(GetPtr(key), GetSize(key),
				GetPtr(encData), GetSize(encData),
				outMeta, outData, inTag, sealedBlockSize);
		}
	}
}
